#include <furi.h>

#include <gui/gui.h>
#include <gui/view_holder.h>
#include <gui/modules/text_box.h>

#include <api_lock.h>

#include <infrared/worker/infrared_transmit.h>

/* generated by fbt from .png files in images folder */
#include <hisense_ir_icons.h>

#define HISENSE_LEADING_MARK  (9060)
#define HISENSE_LEADING_SPACE (4550)
#define HISENSE_STOP_MARK     (550)
#define HISENSE_GAP_SPACE     (7900)

#define HISENSE_BIT_MARK       (560)
#define HISENSE_BIT_ZERO_SPACE (530)
#define HISENSE_BIT_ONE_SPACE  (1700)

#define HISENSE_FRAME_DATA_SIZE (21)
#define HISENSE_FRAME_GAPS_SIZE (2)
#define HISENSE_TIMINGS_SIZE    (343)

typedef struct {
    uint8_t data[HISENSE_FRAME_DATA_SIZE];
    uint8_t gaps[HISENSE_FRAME_GAPS_SIZE];
} HisenseFrame;

typedef struct {
    uint32_t data[HISENSE_TIMINGS_SIZE];
} HisenseTimings;

static HisenseFrame hisense_frame_init(void) {
    static const uint8_t default_data[HISENSE_FRAME_DATA_SIZE] = {
        0x83, 0x06, 0x00, 0x02, 0x00, 0x00,
        0xc0, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x47,
        0x00, 0x02, 0x00, 0x00, 0x08, 0x00, 0x0a
    };
    static const uint8_t default_gaps[HISENSE_FRAME_GAPS_SIZE] = {6, 14};

    HisenseFrame frame;
    memcpy(frame.data, default_data, HISENSE_FRAME_DATA_SIZE);
    memcpy(frame.gaps, default_gaps, HISENSE_FRAME_GAPS_SIZE);

    return frame;
}

static void hisense_frame_recompute_checksum(HisenseFrame* frame) {
    frame->data[13] = 0;
    for (size_t i = 2; i < 13; i++) {
        frame->data[13] ^= frame->data[i];
    }
}

static void hisense_frame_set_temp(HisenseFrame* frame, uint8_t temp) {
    frame->data[3] &= 0b00001111;
    frame->data[3] |= temp << 4;
    hisense_frame_recompute_checksum(frame);
}

static HisenseTimings hisense_timings_create_from_frame(const HisenseFrame* frame) {
    HisenseTimings timings = {0};

    size_t timings_idx = 0;
    size_t gap_idx = 0;

    // Leader burst
    timings.data[timings_idx++] = HISENSE_LEADING_MARK;
    timings.data[timings_idx++] = HISENSE_LEADING_SPACE;

    // For each byte in our frame data...
    for (size_t data_idx = 0; data_idx < HISENSE_FRAME_DATA_SIZE; data_idx++) {
        // Insert an intra-frame gap before specified data indicies.
        if (gap_idx < HISENSE_FRAME_GAPS_SIZE && data_idx == frame->gaps[gap_idx]) {
            timings.data[timings_idx++] = HISENSE_STOP_MARK;
            timings.data[timings_idx++] = HISENSE_GAP_SPACE;
            gap_idx++;
        }
        // Encode each bit, LSB-first.
        for (size_t bit_num = 0; bit_num < 8; bit_num++) {
            if (frame->data[data_idx] & (1 << bit_num)) {
                timings.data[timings_idx++] = HISENSE_BIT_MARK;
                timings.data[timings_idx++] = HISENSE_BIT_ONE_SPACE;
            } else {
                timings.data[timings_idx++] = HISENSE_BIT_MARK;
                timings.data[timings_idx++] = HISENSE_BIT_ZERO_SPACE;
            }
        }
    }

    // Final stop burst
    timings.data[timings_idx] = HISENSE_STOP_MARK;

    return timings;
}

// This function will be called when the user presses the Back button.
static void hisense_ir_back_callback(void* context) {
    FuriApiLock exit_lock = context;
    // Unlock the exit lock, thus enabling the app to exit.
    api_lock_unlock(exit_lock);
}

static void print_frame_data(const HisenseFrame* frame) {
    printf("Frame data (%zu bytes):", HISENSE_FRAME_DATA_SIZE);
    for (size_t i = 0; i < HISENSE_FRAME_DATA_SIZE; ++i) {
        if (i % 16 == 0) printf("\r\n%04zx: ", i); // new line every 16 bytes
        printf("%02x ", frame->data[i]);
    }
    printf("\r\n");
}

static void print_timings_data(const HisenseTimings* timings) {
    printf("Timings data (%zu elements):", HISENSE_TIMINGS_SIZE);
    for (size_t i = 0; i < HISENSE_TIMINGS_SIZE; ++i) {
        if (i % 16 == 0) printf("\r\n%04zx: ", i); // new line every 16 bytes
        printf("%ld ", timings->data[i]);
    }
    printf("\r\n");
}

int32_t hisense_ir_app(void* arg) {
    UNUSED(arg);

    FURI_LOG_I("TEST", "Hello world");
    FURI_LOG_I("TEST", "I'm hisense_ir!");

    // Access the GUI API instance.
    Gui* gui = furi_record_open(RECORD_GUI);
    // Create a TextBox view. The Gui object only accepts
    // ViewPort instances, so we will need to address that later.
    TextBox* text_box = text_box_alloc();
    // Set some text so that the text box is not empty.
    text_box_set_text(
        text_box,
        "ViewHolder is being used\n"
        "to show this TextBox view.\n\n"
        "Scroll down to see more.\n\n\n"
        "Press \"Back\" to exit.");

    // Create a ViewHolder instance. It will serve as an adapter to convert
    // between the View type provided by the TextBox view and the ViewPort type
    // that the GUI can actually display.
    ViewHolder* view_holder = view_holder_alloc();
    // Let the GUI know about this ViewHolder instance.
    view_holder_attach_to_gui(view_holder, gui);
    // Set the view that we want to display.
    view_holder_set_view(view_holder, text_box_get_view(text_box));

    FuriApiLock exit_lock = api_lock_alloc_locked();
    view_holder_set_back_callback(view_holder, hisense_ir_back_callback, exit_lock);

    HisenseFrame frame = hisense_frame_init();

    hisense_frame_set_temp(&frame, 0);
    print_frame_data(&frame);

    HisenseTimings timings = hisense_timings_create_from_frame(&frame);
    print_timings_data(&timings);

    infrared_send_raw(timings.data, HISENSE_TIMINGS_SIZE, true);

    api_lock_wait_unlock_and_free(exit_lock);

    view_holder_set_view(view_holder, NULL);
    view_holder_free(view_holder);
    text_box_free(text_box);
    furi_record_close(RECORD_GUI);

    return 0;
}
